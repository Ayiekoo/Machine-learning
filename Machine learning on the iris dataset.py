#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np ####### Linear algebra #######
import pandas as pd ######## a data processing tool for CSV I/O library #####
import warnings ########## ignore warnings generated by seaborn
warnings.filterwarnings('ignore')

############ data visualization #######
import seaborn as sns
import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')
sns.set(style = 'white', color_codes = True)


# In[2]:


###### loading the dataset
df = "C:/Users/ALEX/Desktop/IRIS.csv"
df = pd.read_csv(df)
print(df)


# In[5]:


df.head(10) #### to give a summary of the first 10 flowers in the dataset


# In[8]:


df.value_counts()


# In[10]:


df['species'].value_counts() #### to give the species in the dataset ####


# In[21]:


df.plot(kind='scatter', x = 'petal_length', y = 'petal_width') ######## use this to make a scatterplot of the iris flower dataset


# In[23]:


df.plot(kind='scatter', x = 'sepal_length', y = 'sepal_width') ######## use this to make a scatterplot of the iris flower dataset


# In[25]:


###### a seaborn shows bivariate scatterplots and univariate histograms in the same figure
sns.jointplot(x = 'sepal_length', y = 'sepal_width', data = df, size = 5)


# In[26]:


sns.jointplot(x = 'petal_length', y = 'petal_width', data = df, size = 5)


# In[28]:


#### let's find shape of the dataset
df.shape


# In[29]:


df.info()


# In[36]:


######### use seaborn's FacedGrid to color the scatterplot by species #############
sns.FacetGrid(df, hue = 'species') \
    .map(plt.scatter, 'sepal_length', 'sepal_width', s=100) \
    .add_legend()


# In[37]:


############# Let's look at the individual features in Seaborn via a boxplot######################
sns.boxplot(x = 'species', y = 'petal_length', data = df)


# In[40]:


####### we can extend these plots by adding a layer of individual points########
### we can use Seaborn's triplot
###
#### we can use the "jitter=True" so that all the points don't fall on a single vertical line above the species
####
### save the resulting axes as an ax on each time the resulting plot to be shown on top of the previous axes

ax = sns.boxplot(data = df, x = 'species', y = 'petal_length')
ax = sns.stripplot(data = df, x = 'species', y = 'petal_length', jitter = True, edgecolor = 'red')


# In[44]:


###### a violin plot combines the benefits of teh previous two plots and simplifies them
### the denser regions of teh data are fatter, and sparser thinner in the violin
sns.violinplot(x = 'species', y = 'petal_length', data = df, s=5)


# In[45]:


###### a violin plot combines the benefits of teh previous two plots and simplifies them
### the denser regions of teh data are fatter, and sparser thinner in the violin
sns.violinplot(x = 'species', y = 'petal_width', data = df, s=5)


# In[46]:


###### a violin plot combines the benefits of teh previous two plots and simplifies them
### the denser regions of teh data are fatter, and sparser thinner in the violin
sns.violinplot(x = 'species', y = 'sepal_length', data = df, s=5)


# In[48]:


###### a violin plot combines the benefits of teh previous two plots and simplifies them
### the denser regions of teh data are fatter, and sparser thinner in the violin
sns.violinplot(x = 'species', y = 'sepal_width', data = df, s=10)


# In[52]:


##### We can obtain a univariate relations using the kdeplot ########
#### we can create and visualize a kernel density estimates of underlying features

sns.FacetGrid(df, hue = 'species') \
    .map(sns.kdeplot, "petal_length") \
    .add_legend()


# In[53]:


##### We can obtain a univariate relations using the kdeplot ########
#### we can create and visualize a kernel density estimates of underlying features

sns.FacetGrid(df, hue = 'species') \
    .map(sns.kdeplot, "petal_width") \
    .add_legend()


# In[54]:


##### We can obtain a univariate relations using the kdeplot ########
#### we can create and visualize a kernel density estimates of underlying features

sns.FacetGrid(df, hue = 'species') \
    .map(sns.kdeplot, "petal_length") \
    .add_legend()


# In[55]:


##### We can obtain a univariate relations using the kdeplot ########
#### we can create and visualize a kernel density estimates of underlying features

sns.FacetGrid(df, hue = 'species') \
    .map(sns.kdeplot, "petal_width") \
    .add_legend()


# In[56]:


df.head()


# In[70]:


df.head(5)


# In[62]:


if 'Id' in df.columns:
    ###### do somethings with the 'Id' column
    pass
else:
    # handle the case where the 'Id' column does not exist
    print("'Id' does not exist in the DataFrame")


# In[ ]:


KeyError: "['Id'] not found in axis"


# In[74]:


sns.pairplot(df, hue='species')


# In[75]:


sns.pairplot(df, hue='species', diag_kind='kde')
### this code shpws diagonal elements, the histograms by default
## we used the kde to update the elements


# In[81]:


df.head()


# In[ ]:




